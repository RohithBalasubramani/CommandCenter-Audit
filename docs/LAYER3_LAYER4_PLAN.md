# CommandCenter — Layer 3 & Layer 4 Implementation Plan

## Current State

| Layer | Name | Status |
|-------|------|--------|
| Layer 1 | Voice I/O (STT/TTS + PersonaPlex) | Done |
| Layer 2 | AI Orchestrator + RAG | Done |
| Layer 3 | Blob (Layout Executor) | **Not started** |
| Layer 4 | Widget Templates | **You have widgets — need integration** |

**What already works end-to-end:**
- User speaks → STT transcribes → Layer 2 orchestrator processes → generates `layout_json` + `voice_response` → TTS speaks response
- The `layout_json` is generated by the backend but **nothing consumes it yet**
- The event bus already emits `LAYOUT_UPDATE` events with layout data
- Widget types (`WidgetSize`, `WidgetInstruction`, `LayoutJSON`) are already defined in `frontend/src/types/index.ts`

---

## What Is Layer 3 (Blob)?

Blob is the **layout executor**. It sits between the AI (Layer 2) and the widgets (Layer 4).

```
Layer 2 says: "Show transformer status as hero, alerts as expanded"
    ↓
Blob receives LayoutJSON
    ↓
Blob arranges widgets on a CSS Grid canvas
    ↓
Layer 4 widgets render with the data Blob passes them
```

**Blob's responsibilities:**
1. Listen for `LAYOUT_UPDATE` events from the event bus
2. Parse the `LayoutJSON` (list of widget instructions)
3. Map widget IDs → actual React components (Layer 4)
4. Place them on a grid with the right sizes
5. Animate transitions when the layout changes
6. Handle user overrides (pin, hide, resize, drag)

---

## What Is Layer 4 (Widgets)?

Layer 4 is a **library of widget components** that Blob can instantiate. Each widget:
- Has a unique ID (e.g., `device-status`, `alert-card`, `kpi-metric`)
- Accepts data from Blob (passed via `WidgetInstruction.data`)
- Renders at any of the 5 sizes: `hero | expanded | normal | compact | hidden`
- Is self-contained — handles its own loading, error, and empty states

---

## What I Need From You

### 1. Your existing widgets

Share or point me to your Layer 4 widget components. For each widget, I need to know:

- **Widget ID** — the string identifier (e.g., `"device-status"`, `"alert-card"`)
- **What it displays** — equipment status? KPI? chart? table? alerts?
- **What data it expects** — what props/data shape does it need?
- **What sizes it supports** — can it render as hero? compact? all sizes?
- **Which domain it belongs to** — industrial, supply, people, tasks, alerts?

Example format:
```
Widget: device-status
  Displays: Real-time equipment status (transformers, generators, etc.)
  Data: { equipmentId, name, status, metrics: { voltage, current, temp } }
  Sizes: hero, expanded, normal
  Domain: industrial
```

### 2. Layout behavior questions

These decisions affect how Blob works:

| Question | Options |
|----------|---------|
| **Grid system** | CSS Grid with fixed columns (e.g., 12-col) vs. free-form absolute positioning? |
| **Transitions** | Smooth animated reflow when layout changes, or instant swap? |
| **User overrides** | Can users pin/unpin, resize, drag widgets? Or is it purely AI-driven? |
| **Persistence** | Should the last layout persist across page reloads? Or always start fresh from AI? |
| **Default layout** | What shows when no voice command has been given yet? Empty canvas? Default dashboard? |
| **Max widgets** | How many widgets can be visible at once? (affects performance) |

### 3. Data flow preference

How should widgets get their data?

| Option | Description |
|--------|-------------|
| **A. Props from Blob** | Blob passes data from `WidgetInstruction.data` (already in the layout_json from Layer 2) |
| **B. Self-fetching** | Each widget fetches its own data from the backend API |
| **C. Real-time push** | Widgets subscribe to a WebSocket/NATS stream for live updates |
| **D. Hybrid** | Initial data from Blob, then widget self-refreshes on an interval or via push |

---

## Proposed Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Canvas (100vw × 100vh)                │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │              Blob (CSS Grid Container)           │    │
│  │                                                  │    │
│  │  ┌──────────────────────────────────────────┐   │    │
│  │  │         Widget: device-status (hero)      │   │    │
│  │  │         [Layer 4 component renders here]  │   │    │
│  │  └──────────────────────────────────────────┘   │    │
│  │                                                  │    │
│  │  ┌──────────────────┐  ┌──────────────────┐    │    │
│  │  │  alert-card       │  │  kpi-metric       │    │    │
│  │  │  (expanded)       │  │  (normal)         │    │    │
│  │  └──────────────────┘  └──────────────────┘    │    │
│  │                                                  │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │  Status Bar: [Spot] [Layer chips] [Voice] [Ledger]   │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### File structure (proposed)

```
frontend/src/components/
├── layer3/
│   ├── Blob.tsx              # Main layout executor
│   ├── BlobGrid.tsx          # CSS Grid wrapper
│   ├── WidgetSlot.tsx        # Individual widget container (handles sizing + transitions)
│   ├── useLayoutState.ts     # Layout state management (current layout + history)
│   └── widgetRegistry.ts     # Maps widget IDs → React components
│
├── layer4/
│   ├── widgets/
│   │   ├── DeviceStatus.tsx  # Equipment status widget
│   │   ├── AlertCard.tsx     # Alert summary widget
│   │   ├── KPIMetric.tsx     # Single KPI display
│   │   ├── ChartWidget.tsx   # Trend chart
│   │   ├── TableWidget.tsx   # Data table
│   │   └── ...               # Your existing widgets
│   ├── WidgetShell.tsx       # Common wrapper (loading, error, resize handle)
│   └── types.ts              # Widget prop types + contracts
```

### Size → CSS Grid mapping

```
hero:     grid-column: span 12; grid-row: span 3;  (full width, 60vh)
expanded: grid-column: span 6;  grid-row: span 2;  (half width, 40vh)
normal:   grid-column: span 4;  grid-row: span 2;  (third width, 30vh)
compact:  grid-column: span 3;  grid-row: span 1;  (quarter width, 15vh)
hidden:   display: none;
```

---

## Implementation Order

| Step | What | Depends on |
|------|------|-----------|
| **1** | You share your widget components + answer the questions above | — |
| **2** | Build widget registry (`widgetRegistry.ts`) — maps IDs to components | Step 1 |
| **3** | Build `WidgetShell.tsx` — common wrapper with size handling | Step 1 |
| **4** | Build `Blob.tsx` + `BlobGrid.tsx` — layout executor | Step 2, 3 |
| **5** | Build `useLayoutState.ts` — state management + event bus listener | Step 4 |
| **6** | Wire into `Canvas.tsx` — Blob becomes the main content area | Step 4 |
| **7** | Test: voice command → layout update → widgets appear | Step 6 |
| **8** | Add transitions/animations | Step 7 |
| **9** | Add user overrides (pin, drag, resize) if needed | Step 7 |

---

## Next Step

**Share your widgets.** Drop the files or describe them, and I'll integrate them into this architecture. The more detail on data shapes and supported sizes, the faster we move.
